; (emacs-wiki-mode)
; (lisp-interaction-mode)

(defun stringsum (st)
  (interactive "sEnter string: ")
  (let (a b c d)
    (setq a (- (aref st 0) 64))
    (setq b (- (aref st 1) 64))
    (setq c (- (aref st 2) 64))
    (setq d (- (aref st 3) 64))
    (message (number-to-string (% (+ a b c d) 10)))
  )
)

; (% 8 5)



; With the aid of function stringsum, a 16-letter passcode can be converted to a 4-digit passcode.

(defun stringsummask (st)
  (interactive "sEnter string: ")
  (let (a b c d n0 n1 n2 n3 n4 n5 n6 n7 n8 nsum)
    (setq a (- (aref st 0) 64))
    (setq b (- (aref st 1) 64))
    (setq c (- (aref st 2) 64))
    (setq d (- (aref st 3) 64))
    ; (message (number-to-string (% (+ a b c d) 10)))
    (setq n0 (% (+ a b c d) 10))
    (setq n1 (random 10))
    (setq n2 (random 10))
    (setq n3 (random 10))
    (setq n4 (random 10))
    (setq n5 (random 10))
    (setq n6 (random 10))
    (setq n7 (random 10))
    (setq nsum (+ n1 n2 n3 n4 n5 n6 n7))
    (setq nsum (% nsum 10))
    (setq n8 (- n0 nsum))
    (setq n8 (% n8 10))
    (if (< n8 0)
      (setq n8 (+ n8 10))
    )
    (concat (number-to-string n1) " " (number-to-string n2) " " (number-to-string n3) " " (number-to-string n4) " " (number-to-string n5) " " (number-to-string n6) " " (number-to-string n7) " " (number-to-string n8))
  )
)

(defun stringsummask2 (st)
  (interactive "sEnter string: ")
  (let (a b c d n0 n1 n2 n3 n4 n5 n6 n7 n8 nsum)
    (setq a (- (aref st 0) 64))
    (setq b (- (aref st 1) 64))
    (setq c (- (aref st 2) 64))
    (setq d (- (aref st 3) 64))
    ; (message (number-to-string (% (+ a b c d) 10)))
    (setq n0 (% (+ a b c d) 10))
    (setq n1 (random 10))
    (setq n2 (random 10))
    (setq n3 (random 10))
    (setq n4 (random 10))
    (setq n5 (random 10))
    (setq n6 (random 10))
    (setq n7 (random 10))
    (setq n8 (random 10))
    (setq n9 (random 10))
    (setq nA (random 10))
    (setq nB (random 10))
    (setq nC (random 10))
    (setq nD (random 10))
    (setq nE (random 10))
    (setq nF (random 10))
    (setq nsum (+ n1 n2 n3 n4 n5 n6 n7 n8 n9 nA nB nC nD nE nF))
    (setq nsum (% nsum 10))
    (setq nG (- n0 nsum))
    (setq nG (% nG 10))
    (if (< nG 0)
      (setq nG (+ nG 10))
    )
    (concat (number-to-string n1) " " (number-to-string n2) " " (number-to-string n3) " " (number-to-string n4) " " (number-to-string n5) " " (number-to-string n6) " " (number-to-string n7) " " (number-to-string n8) " " (number-to-string n9) " " (number-to-string nA) " " (number-to-string nB) " " (number-to-string nC) " " (number-to-string nD) " " (number-to-string nE) " " (number-to-string nF) " " (number-to-string nG))
  )
)


(defun stringcode16tonumcode4 (st)
  "Let the argument be a 16-capital letter string. This function converts it to a set of four lines of eight digits each whose sums modulo 10 is a 4-digit passcode."
  (let (st1 st2 st3 st4 line1 line2 line3 line4)
    (setq st1 (substring st 0 4))
    (setq st2 (substring st 4 8))
    (setq st3 (substring st 8 12))
    (setq st4 (substring st 12 16))
    (setq line1 (stringsummask2 st1))
    (setq line2 (stringsummask2 st2))
    (setq line3 (stringsummask2 st3))
    (setq line4 (stringsummask2 st4))
    (insert (concat "\n" line1 "\n" line2 "\n" line3 "\n" line4))
  )
)
 

(defun plainsum (str1 str2)
  (let (str3 lett1 lett2 lett3)
    (setq str3 "ZZZZZZZZ")
    (dotimes (i 8)
      (setq lett1 (aref str1 i))
      (setq lett2 (aref str2 i))
      (setq lett1 (- lett1 64))
      (setq lett2 (- lett2 64))
      (setq lett3 (+ lett1 lett2))
      (if (>= lett3 27)
        (setq lett3 (- lett3 26))
      )
      (setq lett3 (+ lett3 64))
      (aset str3 i lett3)
    )  ; end dotimes
    str3
  )
)


(defun plainsum2 (str1 str2)
  (let (str3 lett1 lett2 lett3)
    (setq str3 "ZZZZZZZZ")
    (dotimes (i 8)
      (setq lett1 (aref str1 i))
      (setq lett2 (aref str2 i))
      (setq lett1 (- lett1 64))
      (setq lett2 (- lett2 64))
      (setq lett3 (+ lett1 lett2))
      (if (>= lett3 27)
        (setq lett3 (- lett3 26))
      )
      (setq lett3 (+ lett3 64))
      (aset str3 i lett3)
    )  ; end dotimes
    str3
  )
)


(defun leftsort (str1)
  "Batcher's odd-even mergesort used to sort the letters of str1 in increasing alphabetic order."
  (let (lett1 lett2 lst2 j ii jj str2)
    (setq str2 (substring str1 0))
    (dolist (p (list 1 2 4))
      ; (y-or-n-p (concat "p = " (number-to-string p)))
      (cond ((eq p 1) (setq lst2 (list 1)))
            ((eq p 2) (setq lst2 (list 2 1)))
	    ((eq p 4) (setq lst2 (list 4 2 1)))
      )
      (dolist (k lst2)
        ; (y-or-n-p (concat "k = " (number-to-string k)))
        (setq j (% k p))
	(while (<= j (- 7 k))
	  ; (y-or-n-p (concat "j = " (number-to-string j)))
          (dotimes (i k)
	    ; (y-or-n-p (concat "i = " (number-to-string i)))
            (if (eq (floor (/ (+ i j) (* p 2))) (floor (/ (+ i j k) (* p 2))))
              (progn
                (setq ii (+ i j))
		(setq jj (+ i j k))
		; (y-or-n-p (concat "ii = " (number-to-string ii)))
		; (y-or-n-p (concat "jj = " (number-to-string jj)))
		(setq lett1 (aref str2 ii))
		(setq lett2 (aref str2 jj))
		; (y-or-n-p (concat "lett1 = " (number-to-string lett1)))
		; (y-or-n-p (concat "lett2 = " (number-to-string lett2)))
		(if (> lett1 lett2)
		  (progn 
                    (aset str2 jj lett1)
		    (aset str2 ii lett2)
		    ; (y-or-n-p (concat "str1 = " str1))
		  )
                )
              )
            )
          )
	  (setq j (+ j (* 2 k)))
        )   ;end while
      )
    )
    str2
  )
)


(defun rightsort (str1)
  "Batcher's odd-even mergesort used to sort the letters of str1 in decreasing alphabetic order."
  (let (lett1 lett2 lst2 j ii jj str2)
    (setq str2 (substring str1 0))
    (dolist (p (list 1 2 4))
      ; (y-or-n-p (concat "p = " (number-to-string p)))
      (cond ((eq p 1) (setq lst2 (list 1)))
            ((eq p 2) (setq lst2 (list 2 1)))
	    ((eq p 4) (setq lst2 (list 4 2 1)))
      )
      (dolist (k lst2)
        ; (y-or-n-p (concat "k = " (number-to-string k)))
        (setq j (% k p))
	(while (<= j (- 7 k))
	  ; (y-or-n-p (concat "j = " (number-to-string j)))
          (dotimes (i k)
	    ; (y-or-n-p (concat "i = " (number-to-string i)))
            (if (eq (floor (/ (+ i j) (* p 2))) (floor (/ (+ i j k) (* p 2))))
              (progn
                (setq ii (+ i j))
		(setq jj (+ i j k))
		; (y-or-n-p (concat "ii = " (number-to-string ii)))
		; (y-or-n-p (concat "jj = " (number-to-string jj)))
		(setq lett1 (aref str2 ii))
		(setq lett2 (aref str2 jj))
		; (y-or-n-p (concat "lett1 = " (number-to-string lett1)))
		; (y-or-n-p (concat "lett2 = " (number-to-string lett2)))
		(if (< lett1 lett2)
		  (progn 
                    (aset str2 jj lett1)
		    (aset str2 ii lett2)
		    ; (y-or-n-p (concat "str1 = " str1))
		  )
                )
              )
            )
          )
	  (setq j (+ j (* 2 k)))
        )   ;end while
      )
    )
    str2
  )
)

; (rightsort "UNIVERSE")


(defun leftsum (str1 str2)
  (setq str1 (leftsort str1))
  (plainsum str1 str2)
  )


(defun rightsum (str1 str2)
  (setq str1 (rightsort str1))
  (plainsum2 str1 str2)
)


(defun doublesum (pair str)
  (let (strL strR sumL sumR)
    (setq strL (car pair))
    (setq strR (cdr pair))
    (y-or-n-p (concat "strL = " strL))
    (y-or-n-p (concat "str = " str))
    (setq sumL (leftsum strL (substring str 0)))
    (y-or-n-p (concat "sumL = " sumL))
    
    (y-or-n-p (concat "strR = " strR))
    (y-or-n-p (concat "str = " str))
    (setq sumR (rightsum strR (substring str 0)))
    ; (message (rightsum strR (substring str 0)))
    (y-or-n-p (concat "sumR = " sumR))
    (y-or-n-p (concat "sumL = " sumL))
    (cons sumL sumR)
  )
)


(defun addfivewords ()
  (let (sumL sumR summand)
    (setq sumL "ZZZZZZZZ")
    (setq sumR "ZZZZZZZZ")
    (dotimes (i 5)
      (setq summand (read-from-minibuffer "Enter 8-letter all-caps string: "))
      (setq sumL (leftsum sumL summand))
      (setq sumR (rightsum sumR summand))
    )
    (cons sumL sumR)
  )
  )

; (addfivewords)
; ("YYSXEDGA" . "SMZSXPMF")

; (leftsort "JQGZACDL")
; (leftsort "FPIYQQET")
; (leftsort "UXXFVINX")


(defun phi-lett (str)
  "Letter fingerprint of an 8WORD."
  ; (y-or-n-p (concat "str = " str))
  (let ((sum 0) lett)
    (dotimes (i 8)
      (setq lett (aref str i))
      ; (y-or-n-p (concat "lett = " (number-to-string lett)))
      (setq lett (- lett 64))
      ; (y-or-n-p (concat "lett = " (number-to-string lett)))
      (setq sum (+ sum lett))
    )
    (while (> sum 26)
      (setq sum (- sum 26))
    )
    (make-string 1 (+ sum 64))
  )
)

; (phi-lett "UNIVERSE") = "I"
; (make-string 1 9)
; (make-string 9 1)
; (make-string 1 73)


(defun phi-mu (str)
  "Mean of an 8WORD."
  (let ((sum 0) lett)
    (dotimes (i 8)
      (setq lett (aref str i))
      (setq lett (- lett 64))
      (setq sum (+ sum lett))
    )
    (/ sum 8.0)
  )
)

; (phi-mu "UNIVERSE") = 14.125


(defun phi-sigma (str)
  "Standard deviation of an 8WORD."
  (let ((sum 0) lett mu)
    ; (setq mu (aref (phi-let str) 0))
    ; (setq mu (- mu 64))
    (setq mu (phi-mu str))
    (dotimes (i 8)
      (setq lett (aref str i))
      (setq lett (- lett 64))
      (setq sum (+ sum (expt (- lett mu) 2)))
    )
    (/ (ftruncate (* (sqrt (/ sum 8.0)) 1000000)) 1000000)
    ; (truncate (* (sqrt (/ sum 8.0)) 1000000))
  )
)

; (phi-sigma "UNIVERSE") = 6.527585


(defun phi-ordnum (str)
  "'Order number' (natural) of an 8WORD."
  (let (b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 (x0 0) (x1 0) (x2 0) (x3 0) (x4 0) (x5 0) (x6 0) (x7 0) (x8 0) (x9 0) (x10 0))
    (setq b0 (string> (substring str 1 2) (substring str 0 1)))
    (setq b1 (string> (substring str 2 3) (substring str 1 2)))
    (setq b2 (string> (substring str 3 4) (substring str 2 3)))
    (setq b3 (string> (substring str 4 5) (substring str 3 4)))
    (setq b4 (string> (substring str 5 6) (substring str 4 5)))
    (setq b5 (string> (substring str 6 7) (substring str 5 6)))
    (setq b6 (string> (substring str 7 8) (substring str 6 7)))
    (setq b7 (string> (substring str 2 4) (substring str 0 2)))
    (setq b8 (string> (substring str 4 6) (substring str 2 4)))
    (setq b9 (string> (substring str 6 8) (substring str 4 6)))
    (setq b10 (string> (substring str 4 8) (substring str 0 4)))
    (if b0 (setq x0 1))
    (if b1 (setq x1 1))
    (if b2 (setq x2 1))
    (if b3 (setq x3 1))
    (if b4 (setq x4 1))
    (if b5 (setq x5 1))
    (if b6 (setq x6 1))
    (if b7 (setq x7 1))
    (if b8 (setq x8 1))
    (if b9 (setq x9 1))
    (if b10 (setq x10 1)) 
    (+ x0 (* x1 2) (* x2 4) (* x3 8) (* x4 16) (* x5 32) (* x6 64) (* x7 128) (* x8 256) (* x9 512) (* x10 1024))
  )
)


(defun string> (str1 str2)
  "String comparison predicate: greater than."
  (if (string< str1 str2)
    nil
    (if (string= str1 str2)
      nil
      t
    )
  )
)

; (phi-ordnum "UNIVERSE") = 564
; (substring "UNIVERSE" 1 2)
; (string> "N" "U")


(defun createpasscode (n)
  "Input N is the number of 8WORDs which add up to make the new passcode. The output is a reconstruction database which can be used to reconstruct the passcode."
  (let (arr loc flett fsigma fordnum word ok record sumL sumR)
    ; (setq arr (make-vector [0 0 0 0] (1+ n)))
    (setq arr (make-vector (1+ n) [0 0 0 0]))
    (setq sumL "ZZZZZZZZ")
    (setq sumR "ZZZZZZZZ")
    (dotimes (i n)
      (setq ok nil)
      (while (not ok)
        (setq loc (read-string (concat (number-to-string i) " Enter 8WORD's location: ")))
        (setq word (read-string (concat (number-to-string i) " Enter 8WORD: ")))
        (setq ok (y-or-n-p "Is this entry OK?"))
	(if (not (= (length word) 8))
	  (setq ok nil)
	  (if (not (stringp word))
	    (setq ok nil)
	    (if (not (string= (upcase word) word))
	      (setq ok nil)
	    )
	  )
	)
	
      )
      (setq flett (phi-lett word))
      (setq fsigma (phi-sigma word))
      (setq fordnum (phi-ordnum word))
      (setq record (make-vector 4 0))
      (aset record 0 loc)
      (aset record 1 flett)
      (aset record 2 fsigma)
      (aset record 3 fordnum)
      (aset arr i record)
         ; (doublesum (cons sumL sumR) word)
      (setq sumL (leftsum sumL word))
      (setq sumR (rightsum sumR word))
    )
    (setq record [0 0 0 0 0 0])
    (setq flett (phi-lett sumL))
    (setq fsigma (phi-sigma sumL))
    (setq fordnum (phi-ordnum sumL))
    (aset record 0 flett)
    (aset record 1 fsigma)
    (aset record 2 fordnum)
    (setq flett (phi-lett sumR))
    (setq fsigma (phi-sigma sumR))
    (setq fordnum (phi-ordnum sumR))
    (aset record 3 flett)
    (aset record 4 fsigma)
    (aset record 5 fordnum)
    (aset arr n record)
    (insert (prin1-to-string arr))
  )
)

; (insert "505")

; (createpasscode 5) [["Campbell's Biology, page 69, col. 1, par. 1" "Q" 5.39531 737] ["page 69, col. 1, par. 2" "J" 6.652067 1227] ["page 69, col. 2, par. 1" "C" 5.710461 1813] ["page 70, col. 1, par. 1" "Y" 8.014635 1763] ["page 70, col. 2, par. 1" "A" 7.532222 1845] ["D" 6.264982 1318 "D" 6.855654 723]]

; (insert ["a" 3])
; (print ["a" 3])
; (insert (prin1-to-string ["a" 3]))["a" 3]

; (createpasscode 3)[["Campbell's Biology, page 71, col. 1, par. 1" "D" 6.928203 722] ["pg. 71, col. 1, par. 2" "Y" 6.101997 202] ["pg. 71, col. 1, par. 3" "Z" 5.214163 722] ["C" 6.707039 1254 "C" 6.863626 1306]]


(defun reconstructpasscode (dbase)
  "Reconstruct passcode using the reconstruction-database DBASE and a set of 8WORDs inputted interactively by the user."
  (let (loc flett fsigma fordnum sumL sumR word ok i flett1 fsigma1 fordnum1 flett2 fsigma2 fordnum2)
    (setq i 0)
    (setq sumL "ZZZZZZZZ")
    (setq sumR "ZZZZZZZZ")
    (dotimes (j (1- (length dbase)))
      (let (rec)
        (setq rec (aref dbase j))
        (setq loc (aref rec 0))
        (setq flett (aref rec 1))
        (setq fsigma (aref rec 2))
        (setq fordnum (aref rec 3))
        (setq ok nil)
        (while (not ok)
          (setq word (read-string (concat (number-to-string i) ". " loc ": ")))
	  ; (y-or-n-p (concat "word = " word))
	  (if (and (stringp word) (= (length word) 8) (string= word (upcase word)))
            (if (string= (phi-lett word) flett)
	      (if (= (phi-sigma word) fsigma)
	        (if (= (phi-ordnum word) fordnum)
	          (progn
                    (setq ok t)
		    ; (y-or-n-p "ok = t")
		    ; (setq sumL (leftsum sumL word))
		    ; (setq sumR (rightsum sumR word))
                  )
		  (message "Wrong word: fingerprint order numbers do not match.")
                )
	        (message "Wrong word: fingerprint standard deviations do not match.")
	      )
	      (message "Wrong word: fingerprint letters do not match.")
	    )
          )
        )
        (setq i (1+ i))
        (setq sumL (leftsum sumL word))
        (setq sumR (rightsum sumR word))
      )  ;end progn
    )  ;end dotimes
    (let (rec)
      (setq rec (aref dbase (1- (length dbase))))
      ; (y-or-n-p (concat "rec = " (prin1-to-string rec)))
      (setq flett1 (aref rec 0))
      (setq fsigma1 (aref rec 1))
      (setq fordnum1 (aref rec 2))
      (setq flett2 (aref rec 3))
      (setq fsigma2 (aref rec 4))
      (setq fordnum2 (aref rec 5))
      (insert (concat sumL sumR))
      (if (string= (phi-lett sumL) flett1)
        (if (= (phi-sigma sumL) fsigma1)
	  (if (= (phi-ordnum sumL) fordnum1)
	    (if (string= (phi-lett sumR) flett2)
	      (if (= (phi-sigma sumR) fsigma2)
	        (if (= (phi-ordnum sumR) fordnum2)
		  (progn 
	            ; (insert (concat sumL sumR))
		    (y-or-n-p "The passcode's fingerprints match those on record.")
		  )
		  (y-or-n-p "Error: right-sum's fingerprint order number does not match that in the record.")
		)
		(y-or-n-p "Error: right-sum's fingerprint standard deviation does not match that in the record.")
	      )
	      (y-or-n-p "Error: right-sum's fingerprint letter does not match that in the record.")
            )
            (y-or-n-p "Error: left-sum's fingerprint order number does not match that in the record.")
	  )
          (y-or-n-p "Error: left-sum's fingerprint standard deviation does not match that in the record.")
	)
	(y-or-n-p "Error: left-sum's fingerprint letter does not match that in the record.")
      )
    )
            
  )
)

; (reconstructpasscode [["Campbell's Biology, page 69, col. 1, par. 1" "Q" 5.39531 737] ["page 69, col. 1, par. 2" "J" 6.652067 1227] ["page 69, col. 2, par. 1" "C" 5.710461 1813] ["page 70, col. 1, par. 1" "Y" 8.014635 1763] ["page 70, col. 2, par. 1" "A" 7.532222 1845] ["D" 6.264982 1318 "D" 6.855654 723]])KCHWTLSLHWZMFJHN

; (aref [["Campbell's Biology, page 69, col. 1, par. 1" "Q" 5.39531 737] ["page 69, col. 1, par. 2" "J" 6.652067 1227] ["page 69, col. 2, par. 1" "C" 5.710461 1813] ["page 70, col. 1, par. 1" "Y" 8.014635 1763] ["page 70, col. 2, par. 1" "A" 7.532222 1845] ["D" 6.264982 1318 "D" 6.855654 723]] 2)

; (reconstructpasscode [["Campbell's Biology, page 71, col. 1, par. 1" "D" 6.928203 722] ["pg. 71, col. 1, par. 2" "Y" 6.101997 202] ["pg. 71, col. 1, par. 3" "Z" 5.214163 722] ["C" 6.707039 1254 "C" 6.863626 1306]])MMTVOBDRKDGBQVOC

(defun alterpasscode (dbase)
  "Reconstruct passcode using the reconstruction-database DBASE and a set of 8WORDs inputted interactively by the user."
  (let (loc flett fsigma fordnum sumL sumR word ok i flett1 fsigma1 fordnum1 flett2 fsigma2 fordnum2)
    (setq i 0)
    (setq sumL "ZZZZZZZZ")
    (setq sumR "ZZZZZZZZ")
    (dotimes (j (1- (length dbase)))
      (let (rec)
        (setq rec (aref dbase j))
        (setq loc (aref rec 0))
        (setq flett (aref rec 1))
        (setq fsigma (aref rec 2))
        (setq fordnum (aref rec 3))
        (setq ok nil)
        (while (not ok)
          (setq word (read-string (concat (number-to-string i) ". " loc ": ")))
	  ; (y-or-n-p (concat "word = " word))
	  (if (and (stringp word) (= (length word) 8) (string= word (upcase word)))
            (if (string= (phi-lett word) flett)
	      (if (= (phi-sigma word) fsigma)
	        (if (= (phi-ordnum word) fordnum)
	          (progn
                    (setq ok t)
		    ; (y-or-n-p "ok = t")
		    ; (setq sumL (leftsum sumL word))
		    ; (setq sumR (rightsum sumR word))
                  )
		  (message "Wrong word: fingerprint order numbers do not match.")
                )
	        (message "Wrong word: fingerprint standard deviations do not match.")
	      )
	      (message "Wrong word: fingerprint letters do not match.")
	    )
          )
        )
        (setq i (1+ i))
        (setq sumL (leftsum sumL word))
        (setq sumR (rightsum sumR word))
      )  ;end progn
    )  ;end dotimes
    (progn
      ; (setq rec (aref dbase (1- (length dbase))))
      ; (y-or-n-p (concat "rec = " (prin1-to-string rec)))
      (setq flett1 (phi-lett sumL))
      (setq fsigma1 (phi-sigma sumL))
      (setq fordnum1 (phi-ordnum sumL))
      (setq flett2 (phi-lett sumR))
      (setq fsigma2 (phi-sigma sumR))
      (setq fordnum2 (phi-ordnum sumR))
      ; (insert (concat sumL sumR))
      (y-or-n-p "Ready?")
      (y-or-n-p (concat "flett1 = " flett1))
      (y-or-n-p (concat "fsigma1 = " (number-to-string fsigma1)))
      (y-or-n-p (concat "fordnum1 = " (number-to-string fordnum1)))
      (y-or-n-p (concat "flett2 = " flett2))
      (y-or-n-p (concat "fsigma2 = " (number-to-string fsigma2)))
      (y-or-n-p (concat "fordnum2 = " (number-to-string fordnum2)))

      (insert "\nOUTPUT:")
      (insert (concat "\nflett1 = " flett1))
      (insert (concat "\nfsigma1 = " (number-to-string fsigma1)))
      (insert (concat "\nfordnum1 = " (number-to-string fordnum1)))
      (insert (concat "\nflett2 = " flett2))
      (insert (concat "\nfsigma2 = " (number-to-string fsigma2)))
      (insert (concat "\nfordnum2 = " (number-to-string fordnum2) "\n"))
    )
  )
)

;(progn
;  (insert "M\n")
;  (insert (concat (number-to-string 5.76) "\n"))
;  (insert "52\n")
;)M
;5.76
;52



(defun createquiz (n)
  "Input N is the number of 8WORDs which add up to make the new passcode. The output is a reconstruction database which can be used to reconstruct the passcode."
  (let (arr loc flett fsigma fordnum word ok record sumL sumR)
    ; (setq arr (make-vector [0 0 0 0] (1+ n)))
    (setq arr (make-vector (1+ n) [0 0 0 0]))
    (setq sumL "ZZZZZZZZ")
    (setq sumR "ZZZZZZZZ")
    (dotimes (i n)
      (setq ok nil)
      (while (not ok)
        (setq loc (read-string (concat (number-to-string i) " Enter 8WORD's location: ")))
        (setq word (read-string (concat (number-to-string i) " Enter 8WORD: ")))
        (setq ok (y-or-n-p "Is this entry OK?"))
        (if (not (stringp word))      ; check-entry
	  (setq ok nil)
	  (if (> (length word) 16)
	    (setq ok nil)
	  )
	)
        (while (< (length word) 8)
          (setq word (concat "Z" word))
        )
	(if (> (length word) 8)
	  (progn
            (while (< (length word) 16)
              (setq word (concat "Z" word))
            )
	    (let (word1 word2)
              (setq word1 (substring word 0 8))
	      (setq word2 (substring word 8 16))
	      (setq word (plainsum word1 word2))
            )
	  )
        )        ; end check-entry
      )
      (setq flett (phi-lett word))
      (setq fsigma (phi-sigma word))
      (setq fordnum (phi-ordnum word))
      (setq record (make-vector 4 0))
      (aset record 0 loc)
      (aset record 1 flett)
      (aset record 2 fsigma)
      (aset record 3 fordnum)
      (aset arr i record)
         ; (doublesum (cons sumL sumR) word)
      (setq sumL (leftsum sumL word))
      (setq sumR (rightsum sumR word))
    )
    (setq record [0 0 0 0 0 0])
    (setq flett (phi-lett sumL))
    (setq fsigma (phi-sigma sumL))
    (setq fordnum (phi-ordnum sumL))
    (aset record 0 flett)
    (aset record 1 fsigma)
    (aset record 2 fordnum)
    (setq flett (phi-lett sumR))
    (setq fsigma (phi-sigma sumR))
    (setq fordnum (phi-ordnum sumR))
    (aset record 3 flett)
    (aset record 4 fsigma)
    (aset record 5 fordnum)
    (aset arr n record)
    (insert (prin1-to-string arr))
  )
)


(defun processword (word)
      (let ((ok t))
        (if (not (stringp word))      ; check-entry
	  (setq ok nil)
	  (progn
	    (setq word (upcase word))
	    (if (> (length word) 16)
	      (setq ok nil)
	    )
	  )
	)
        (while (< (length word) 8)
          (setq word (concat "Z" word))
        )
	(if (> (length word) 8)
	  (progn
            (while (< (length word) 16)
              (setq word (concat "Z" word))
            )
	    (let (word1 word2)
              (setq word1 (substring word 0 8))
	      (setq word2 (substring word 8 16))
	      (setq word (plainsum word1 word2))
            )
	  )
        )        ; end check-entry
	(if ok
          word
	  ""
        )
      )
)

(defun runquiz (dbase)
  "Reconstruct passcode using the reconstruction-database DBASE and a set of 8WORDs inputted interactively by the user."
  (let (loc flett fsigma fordnum sumL sumR word ok i flett1 fsigma1 fordnum1 flett2 fsigma2 fordnum2)
    (setq i 0)
    (setq sumL "ZZZZZZZZ")
    (setq sumR "ZZZZZZZZ")
    (dotimes (j (1- (length dbase)))
      (let (rec)
        (setq rec (aref dbase j))
        (setq loc (aref rec 0))
        (setq flett (aref rec 1))
        (setq fsigma (aref rec 2))
        (setq fordnum (aref rec 3))
        (setq ok nil)
        (while (not ok)
          (setq word (read-string (concat (number-to-string i) ". " loc ": ")))
	  ; (y-or-n-p (concat "word = " word))
	  (setq word (processword word))
	  (if (and (stringp word) (= (length word) 8) (string= word (upcase word)))
            (if (string= (phi-lett word) flett)
	      (if (= (phi-sigma word) fsigma)
	        (if (= (phi-ordnum word) fordnum)
	          (progn
                    (setq ok t)
		    ; (y-or-n-p "ok = t")
		    ; (setq sumL (leftsum sumL word))
		    ; (setq sumR (rightsum sumR word))
                  )
		  (message "Wrong word: fingerprint letters do not match.")
                )
	        (message "Wrong word: fingerprint standard deviations do not match.")
	      )
	      (message "Wrong word: fingerprint order numbers do not match.")
	    )
          )
        )
        (setq i (1+ i))
        (setq sumL (leftsum sumL word))
        (setq sumR (rightsum sumR word))
      )  ;end progn
    )  ;end dotimes
    (let (rec)
      (setq rec (aref dbase (1- (length dbase))))
      ; (y-or-n-p (concat "rec = " (prin1-to-string rec)))
      (setq flett1 (aref rec 0))
      (setq fsigma1 (aref rec 1))
      (setq fordnum1 (aref rec 2))
      (setq flett2 (aref rec 3))
      (setq fsigma2 (aref rec 4))
      (setq fordnum2 (aref rec 5))
      (if (string= (phi-lett sumL) flett1)
        (if (= (phi-sigma sumL) fsigma1)
	  (if (= (phi-ordnum sumL) fordnum1)
	    (if (string= (phi-lett sumR) flett2)
	      (if (= (phi-sigma sumR) fsigma2)
	        (if (= (phi-ordnum sumR) fordnum2)
	          (message "Good!"); (insert (concat sumL sumR))
		  (message "Error: right-sum's fingerprint order number does not match that in the record.")
		)
		(message "Error: right-sum's fingerprint standard deviation does not match that in the record.")
	      )
	      (message "Error: right-sum's fingerprint letter does not match that in the record.")
            )
            (message "Error: left-sum's fingerprint order number does not match that in the record.")
	  )
          (message "Error: left-sum's fingerprint standard deviation does not match that in the record.")
	)
	(message "Error: left-sum's fingerprint letter does not match that in the record.")
      )
    )
            
  )
)

; (createquiz 3)[["In the cell wall of a plant, many parallel cellulose molecules, held together by hydrogen bonds between hydroxyl groups of the glucose monomers, are arranged in units called ____." "C" 5.254462 538] ["Several microfibrils intertwined form a ____ fibril, and several fibrils may in turn be supercoiled." "Z" 4.949747 1717] ["These strong cables are an excellent building material, both for the plant and for humans, who use cellulose-rich wood for ____." "S" 8.425222 356] ["S" 8.724068 1483 "V" 6.552671 1258]]

; (runquiz [["In the cell wall of a plant, many parallel cellulose molecules, held together by hydrogen bonds between hydroxyl groups of the glucose monomers, are arranged in units called ____." "C" 5.254462 538] ["Several microfibrils intertwined form a ____ fibril, and several fibrils may in turn be supercoiled." "Z" 4.949747 1717] ["These strong cables are an excellent building material, both for the plant and for humans, who use cellulose-rich wood for ____." "S" 8.425222 356] ["S" 8.724068 1483 "V" 6.552671 1258]])CDSEYVCPRQYEVIJT


(defun createinquiry (n)
  "Input N is the number of 8WORDs which add up to make the new passcode. The output is a reconstruction database which can be used to reconstruct the passcode."
  (let (arr loc flett fsigma fordnum word ok record sumL sumR)
    ; (setq arr (make-vector [0 0 0 0] (1+ n)))
    ; (setq arr (make-vector (1+ n) [0 0 0 0]))
    (setq arr (make-vector n [0 0 0 0]))
    ; (setq sumL "ZZZZZZZZ")
    ; (setq sumR "ZZZZZZZZ")
    (dotimes (i n)
      (setq ok nil)
      (while (not ok)
        (setq loc (read-string (concat (number-to-string i) " Enter 8WORD's location: ")))
        (setq word (read-string (concat (number-to-string i) " Enter 8WORD: ")))
        (setq ok (y-or-n-p "Is this entry OK?"))
        (if (not (stringp word))      ; check-entry
	  (setq ok nil)
	  (if (> (length word) 24)
	    (setq ok nil)
	  )
	)
	(dotimes (i (length word))
          (let (char)
            (setq char (aref word i))
	    (if (eq char 32)
              (aset word i 90)
            )
          )
        )
        (while (< (length word) 8)
          (setq word (concat "Z" word))
        )
	(if (> (length word) 8)
	  (if (<= (length word) 16)
	    (progn                           ; THEN
              (while (< (length word) 16)
                (setq word (concat "Z" word))
              )
	      (let (word1 word2)
                (setq word1 (substring word 0 8))
	        (setq word2 (substring word 8 16))
	        (setq word (plainsum word1 word2))
              )
	    )
	    (progn                           ; ELSE
	      (while (< (length word) 24)
                (setq word (concat "Z" word))
              )
	      (let (word1 word2 word3)
                (setq word1 (substring 0 8))
		(setq word2 (substring 8 16))
		(setq word3 (substring 16 24))
		(setq word (plainsum (plainsum word1 word2) word3))
              )
	    )
	  )  
        )        ; end check-entry
      )
      (setq flett (phi-lett word))
      (setq fsigma (phi-sigma word))
      (setq fordnum (phi-ordnum word))
      (setq record (make-vector 4 0))
      (aset record 0 loc)
      (aset record 1 flett)
      (aset record 2 fsigma)
      (aset record 3 fordnum)
      (aset arr i record)
         ; (doublesum (cons sumL sumR) word)
      ; (setq sumL (leftsum sumL word))
      ; (setq sumR (rightsum sumR word))
    )
    ; (setq record [0 0 0 0 0 0])
    ; (setq flett (phi-lett sumL))
    ; (setq fsigma (phi-sigma sumL))
    ; (setq fordnum (phi-ordnum sumL))
    ; (aset record 0 flett)
    ; (aset record 1 fsigma)
    ; (aset record 2 fordnum)
    ; (setq flett (phi-lett sumR))
    ; (setq fsigma (phi-sigma sumR))
    ; (setq fordnum (phi-ordnum sumR))
    ; (aset record 3 flett)
    ; (aset record 4 fsigma)
    ; (aset record 5 fordnum)
    ; (aset arr n record)
    (insert (prin1-to-string arr))
  )
)

;      (let (word)
;        (setq word "BIG SUR")
;	(dotimes (i (length word))
;          (let (char)
;            (setq char (aref word i));
;	    (if (eq char 32)
;              (aset word i 90)
;            )
;          )
;        )
;	word
;      )


(defun processword (word)
      (let ((ok t))
        (if (not (stringp word))      ; check-entry
	  (setq ok nil)
	  (if (> (length word) 24)
	    (setq ok nil)
	  )
	)
	(dotimes (i (length word))
          (let (char)
            (setq char (aref word i))
	    (if (eq char 32)
              (aset word i 90)
            )
          )
        )	
        (while (< (length word) 8)
          (setq word (concat "Z" word))
        )
	(if (> (length word) 8)
	  (if (<= (length word) 16)
	    (progn                           ; THEN
              (while (< (length word) 16)
                (setq word (concat "Z" word))
              )
	      (let (word1 word2)
                (setq word1 (substring word 0 8))
	        (setq word2 (substring word 8 16))
	        (setq word (plainsum word1 word2))
              )
	    )
	    (progn                           ; ELSE
	      (while (< (length word) 24)
                (setq word (concat "Z" word))
              )
	      (let (word1 word2 word3)
                (setq word1 (substring 0 8))
		(setq word2 (substring 8 16))
		(setq word3 (substring 16 24))
		(setq word (plainsum (plainsum word1 word2) word3))
              )
	    )
	  )  
        )        ; end check-entry
	(if ok
          word
	  ""
        )
      )
)

(defun runinquiry (dbase)
  "Reconstruct passcode using the reconstruction-database DBASE and a set of 8WORDs inputted interactively by the user."
  (let (loc flett fsigma fordnum sumL sumR word ok i flett1 fsigma1 fordnum1 flett2 fsigma2 fordnum2)
    (setq i 0)
    (dotimes (j (length dbase))
      (let (rec)
        (setq rec (aref dbase j))
        (setq loc (aref rec 0))
        (setq flett (aref rec 1))
        (setq fsigma (aref rec 2))
        (setq fordnum (aref rec 3))
        (setq ok nil)
        (while (not ok)
          (setq word (read-string (concat (number-to-string i) ". " loc ": ")))
	  ; (y-or-n-p (concat "word = " word))
	  (setq word (processword word))
	  (if (and (stringp word) (= (length word) 8) (string= word (upcase word)))
            (if (string= (phi-lett word) flett)
	      (if (= (phi-sigma word) fsigma)
	        (if (= (phi-ordnum word) fordnum)
	          (progn
                    (setq ok t)
                  )
		  (message "Wrong word: fingerprint order numbers do not match.")
                )
	        (message "Wrong word: fingerprint standard deviations do not match.")
	      )
	      (message "Wrong word: fingerprint letters do not match.")
	    )
          )
        )
        (setq i (1+ i))
      )  ;end progn
    )  ;end dotimes
  )
)


;(stringcode16tonumcode4 "CDSEYVCPRQYEVIJT")
;5 1 8 4 0 6 2 2 5 3 2 6 4 8 8 7
;5 5 2 6 5 1 8 3 4 0 3 8 5 7 0 4
;4 2 7 0 1 6 7 3 9 0 6 4 1 5 8 2
;1 8 4 8 6 9 4 8 6 2 9 9 4 2 3 8

;What function stringcode16tonumcode4 does is it converts (in a lossy/nonreversible way) a 16-letter passcode into a 4-digit passcode. However, it does not show the 4-digit passcode directly, because then it would be too easy to memorize by the one who would see it. Instead it is displayed more implicitly, by showing four lines of digits. Each line of digits should be added modulo 10, with the modular arithmetic done entirely in the head, with resulting digits being inputted one at a time into the passcode field for which it is meant.

;When a 4-digit passcode is set up it needs to be inputted twice. So the function can be run again, e.g.
;(stringcode16tonumcode4 "CDSEYVCPRQYEVIJT")
;5 6 0 4 9 2 9 3 7 9 2 1 5 7 4 8
;7 9 0 6 4 3 9 5 1 1 4 0 6 8 3 0
;9 3 1 8 5 5 4 5 6 0 4 0 4 9 7 5
;3 2 6 7 8 1 3 4 7 8 5 9 7 6 1 4

;yielding a second set of four rows, which, nonetheless (despite being different), add up modularly to the same set of four digits as the first set of four rows.
